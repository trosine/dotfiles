#!/usr/bin/perl
#; possible future use of emoji:
#; â—ï¸ â• â“ â” â€¼ï¸ â‰ï¸ âŽ âœ… âœ³ï¸ â‡ï¸ ðŸŒ€ â˜‘ï¸ ðŸ”˜ âšªï¸ âš«ï¸ ðŸ”´ ðŸ”µ ðŸ”¸ ðŸ”¹ ðŸ”¶ ðŸ”· ðŸ”º â–ªï¸ â–«ï¸ â¬›ï¸ â¬œï¸ ðŸ”» â—¼ï¸ â—»ï¸ â—¾ï¸ â—½ï¸ ðŸ”² ðŸ”³ â™¦ï¸ ðŸ’¬ âš¡ï¸
#; âœ¨ ðŸ”¥ ðŸ’¥ ðŸ’§ ðŸŒ± ðŸŒ¿ ðŸ’© ðŸ–• ðŸŽ¯ ðŸš¦ ðŸš¥ âš“ï¸ â˜ ï¸ â›”ï¸ ðŸ“› ðŸš« âŒ â­•ï¸ ðŸ’¢ â™»ï¸vðŸ”° ðŸ”… ðŸ”† ðŸ”± âšœ ðŸŒ âž• âž– âž— âœ–ï¸ ðŸ’² 
#; cases:
use strict;
use Fcntl ':flock';
use File::Copy;
use File::Slurp;
use POSIX qw(setsid);

my $process_status = $ENV{'REMOTE_STATUS'} || 0;
my $skip_branches  = $ENV{'SKIP_BRANCHES'} || 0;

my $color_reset="\\[\x1b[0m\\]";
my $color_stale="\\[\x1b[38;5;1m\\]";
my $color_branch="\\[\x1b[38;5;208m\\]";
my $color_stashed="\\[\x1b[38;5;190m\\]";
my $proj = undef;
my $stashed = 0;
my $prefix = '';
my $suffix = '';
my $translate_map = {
  #; '*' => 'ðŸ’¥ ',
  #; '%' => 'âœ¨ ',
  #; '|' => 'ðŸŒ¿ ',
};

our $remote_heads = '';

my $path = $ENV{'PWD'};
my $home = $ENV{'HOME'};

my $std_git_prompt = '/Library/Developer/CommandLineTools/usr/share/git-core/git-prompt.sh';

my $git = '';

if ( -f $std_git_prompt ) {
  my $generate_git_prompt = "bash -c '";
  $generate_git_prompt .= "source $std_git_prompt ; ";
  $generate_git_prompt .= "GIT_PS1_SHOWDIRTYSTATE=1 ; ";
  $generate_git_prompt .= "GIT_PS1_SHOWSTASHSTATE=1 ; ";
  $generate_git_prompt .= "GIT_PS1_SHOWUNTRACKEDFILES=1 ; ";
  $generate_git_prompt .= "GIT_PS1_SHOWUPSTREAM=\"auto\" ; ";
  $generate_git_prompt .= "__git_ps1 \"\%s\" ";
  $generate_git_prompt .= "'";
  $git = `$generate_git_prompt`;
  #; foreach my $char (keys (%$translate_map)) {
  #;   my $replace = $translate_map->{$char};
  #;   $char = quotemeta $char;
  #;   $git =~ s/$char/${replace}/;
  #; }
}

#; emulate \w
$path =~ s/^${home}/\~/;

#; format any home proj subdirs
if ( $path =~ s/\~\/proj\/([^\/]+)// ) {
  $proj = $1;

  #; strip off project directory
  $path =~ s/^\///;

  #; wrap the prompt in []
  $prefix = '[';
  $suffix = "]";

}

#: replace the user with the project name (if we're in a project)
my $user = $proj ? $proj : '\\u';

#; by default show the hostname
my $host_info = '@\\h';

if ($git) {
  my $git_color = $color_reset;
  my $branch_name = 'master';
  if ($git =~ m/^master/) {
    if ($git =~ m/\</) {
      $git_color = $color_stale;
    }

    if (!$skip_branches) {
      my $branch_count = 1;
      chomp($branch_count = `git branch 2>/dev/null | wc -l`);
      if ($branch_count > 1) {
        $git .= '|';
      }
    }
  }
  else {
    $git_color = $color_branch;
    chomp($branch_name = `git rev-parse --abbrev-ref HEAD 2>/dev/null`);

    if (!$skip_branches) {
      my $branch_count = 1;
      chomp($branch_count = `git branch 2>/dev/null | wc -l`);
      if ($branch_count > 2) {
        $git .= '|';
      }
    }
  }

  foreach my $char (keys (%$translate_map)) {
    my $replace = $translate_map->{$char};
    $char = quotemeta $char;
    $git =~ s/$char/${replace}/;
  }

  $git = $git_color . $git . $color_reset;

  if ($process_status) {
    chomp(my $git_dir = `git rev-parse --git-dir 2>/dev/null`);
    if (-d $git_dir) {

      #; read previously written remote_heads
      $remote_heads = read_file( "$git_dir/.myprompt.heads", err_mode => 'quiet' );

      my $behind_master = '';
      my $behind_branch = '';
      if (behind_origin('master')) {
        $behind_master = 'm';
      }
      if ($branch_name ne 'master' && behind_origin($branch_name)) {
        $behind_branch = 'b';
      }
      if ($behind_master || $behind_branch) {
        $git = $color_stale . '<' . $behind_master . $behind_branch . $color_reset . '-' . $git;
      }

      #; fire-off an async update of our remote heads
      async_ref_update($git_dir);
    }
  }
  if ($proj) {
    $host_info = "/$git";
  }
  else {
    $host_info .= "($git)";
  }
}

#; root gets a '#'
my $symbol = $> ? '$' : '#';

#; put it all together
print "${color_reset}${prefix}${user}${host_info}${suffix} ${path}${symbol} \n";

sub behind_origin {
  my ($branch) = @_;

  #; parse the HEAD of origin/branch
  my $remote_head;
  foreach my $line (split("\n",$remote_heads)) {
    if ($line =~ m/^(\S+)\s+refs\/heads\/${branch}/) {
      $remote_head = $1;
    }
  }
  return 0 unless $remote_head;

  #; test if we have this reference in our local repository
  system("git show $remote_head >/dev/null 2>&1");

  return ($? >> 8 != 0)
}

sub async_ref_update {
  my ($git_dir) = @_;
  my $pid = fork;
  if (defined($pid)) {
    if (!$pid) {
      #; child

      #; separate this process from it's parent
      setsid();
      close(STDOUT); close (STDIN); close (STDERR);


      #; obtain lockfile (or bail out)
      my $lock_file    = "$git_dir/.myprompt.lock";
      my $remote_heads = "$git_dir/.myprompt.heads";
      my $lock_handle;
      if (open($lock_handle,">$lock_file")) {
        if (flock( $lock_handle, LOCK_EX | LOCK_NB )) {
          #; fetch remote heads
          system("git ls-remote -h origin > $remote_heads.tmp 2>/dev/null");
          move("$remote_heads.tmp",$remote_heads);
        }
      }
      exit;
    }
  }

}
